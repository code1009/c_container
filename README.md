# c_container

- C 언어로 작성된 경량 컨테이너와 고정 메모리 풀
- C++의 STL의 컨테이너 기능을 소형 MCU에서 사용하기 위해 제작
- (미션 크리티컬 시스템 제약 사항을 적용하기 위해) HEAP 동적메모리 사용이 없음


## 특징
- 모든 컨테이너는 내부적으로 사용자 제공 버퍼를 사용하여 비침임형 컨테이너 구현하며, 요소 자체는 포인터로 관리
  - 예: `cc_element_t[]`, `cc_pair_t[]`, `cc_hash_entry_t[]`
  - 요소 메모리는 외부에서 할당/해제
- Simple Segregated Storage 알고리즘을 통해 메모리풀 구현


## 컨테이너

- cc_vector (벡터)
  - 역할: 
      - 인덱스 기반의 순차 컨테이너. 요소를 뒤에 추가하거나 임의 위치에 삽입/삭제 가능.
  - 특징:
      - 고정 용량의 초기 cc_element_t 배열 기반
      - 고정 최대 개수
      - 동적 리사이즈 없음
      - 요소는 void* 포인터로 저장
  - 사용 시 유의점: 
      - 요소 메모리는 외부에서 할당/관리(주로 `cc_allocator_t` 또는 메모리 풀 사용).

- cc_map (정렬된 맵)
  - 역할: 
      - 키/값 쌍을 정렬된 순서로 유지하는 컨테이너(이진 탐색 기반 삽입 위치 탐색).
  - 특징:
      - 정렬 기준과 동등 비교는 사용자 콜백(`cc_less_t`, `cc_equal_t`)으로 제공. 
      - 고정 용량의 초기 cc_pair_t 배열 기반.
  - 사용 시 유의점: 
      - 중복 키는 허용되지 않음(추가 시 기존 키가 있으면 실패)
      - 키/값 포인터는 외부에서 관리.

- cc_hash_table (오픈 어드레싱 해시 테이블)
  - 역할: 
      - 해시 기반 빠른 검색/삽입/삭제를 지원하는 테이블(오픈 어드레싱).
  - 특징:
      - 키 생성기(`cc_hash_key_generate_t`)와 동등 비교(`cc_equal_t`)를 사용자 제공. 
      - 선형 프로빙(구현상 기본) 사용. 
      - 항목 테이블은 사용자 제공 `cc_hash_entry_t[]`.
  - 사용 시 유의점: 
      - 테이블 크기(버킷 수)는 생성 시 결정.

 
## 메모리 모델
- 모든 컨테이너는 요소 포인터만 저장합니다. 실제 데이터 버퍼는 사용자가 준비해야 합니다.
    - 스택/정적 배열 또는 메모리 풀.
- 컨테이너 내부 요소 버퍼(예: `cc_element_t elements[N]`)는 컨테이너 생성 시 제공 해야 합니다.
    - 이 버퍼의 크기가 컨테이너의 최대 용량을 결정합니다.
- 라이브러리는 기본적으로 스레드 안전하지 않습니다. 
    - RTOS 사용시 잠금기능을 추가해야합니다.


